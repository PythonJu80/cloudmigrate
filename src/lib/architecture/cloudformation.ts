/**
 * CloudFormation Template Generator & Deployer
 * 
 * This is the CORRECT way to deploy AWS architectures:
 * 1. Convert architecture nodes/edges â†’ CloudFormation template
 * 2. Call CloudFormation API (CreateStack/UpdateStack/DeleteStack)
 * 3. Let AWS handle all resource creation, dependencies, rollbacks
 * 
 * NOT manual SDK calls per resource. That's fragile and not AWS-recommended.
 */

import { Node, Edge } from "@xyflow/react";
import { CloudFormationClient, CreateStackCommand, UpdateStackCommand, DeleteStackCommand, DescribeStacksCommand, DescribeStackEventsCommand, waitUntilStackCreateComplete, waitUntilStackUpdateComplete, waitUntilStackDeleteComplete } from "@aws-sdk/client-cloudformation";
import { getAwsCredentials } from "../secrets";
import { validateCloudFormationTemplate } from "./cloudformation-validator";

// ============================================
// TYPES
// ============================================

export interface CloudFormationTemplate {
  AWSTemplateFormatVersion: "2010-09-09";
  Description: string;
  Parameters?: Record<string, any>;
  Resources: Record<string, CloudFormationResource>;
  Outputs?: Record<string, any>;
}

export interface CloudFormationResource {
  Type: string;
  Properties: Record<string, any>;
  DependsOn?: string | string[];
}

export interface DeploymentResult {
  success: boolean;
  stackId?: string;
  stackName: string;
  status: string;
  outputs?: Record<string, string>;
  error?: string;
}

// ============================================
// TEMPLATE GENERATOR
// ============================================

/**
 * Convert architecture nodes to CloudFormation template
 */
export function generateCloudFormationTemplate(
  nodes: Node[],
  edges: Edge[],
  architectureName: string,
  description?: string
): CloudFormationTemplate {
  const template: CloudFormationTemplate = {
    AWSTemplateFormatVersion: "2010-09-09",
    Description: description || `CloudFormation template for ${architectureName} - Generated by CloudMigrate`,
    Resources: {},
    Outputs: {},
  };

  // Process each node and convert to CloudFormation resource
  for (const node of nodes) {
    const resourceType = node.data?.type || node.data?.serviceId;
    const config = node.data?.config || node.data || {};
    const logicalId = sanitizeLogicalId(node.id);

    const cfResource = convertNodeToResource(node, logicalId, config, nodes, edges);
    if (cfResource) {
      template.Resources[logicalId] = cfResource;
    }
  }

  // Add outputs for key resources
  addOutputs(template, nodes);

  return template;
}

/**
 * Convert a single node to CloudFormation resource
 */
function convertNodeToResource(
  node: Node,
  logicalId: string,
  config: Record<string, any>,
  allNodes: Node[],
  edges: Edge[]
): CloudFormationResource | null {
  const type = node.data?.type || (node.data?.serviceId as string)?.split("-")[0];
  const label = config.name || config.label || logicalId;

  switch (type) {
    case "vpc":
      return {
        Type: "AWS::EC2::VPC",
        Properties: {
          CidrBlock: config.cidrBlock || "10.0.0.0/16",
          EnableDnsHostnames: true,
          EnableDnsSupport: true,
          Tags: [{ Key: "Name", Value: label }],
        },
      };

    case "subnet":
      const vpcRef = findParentRef(node, allNodes, "vpc");
      return {
        Type: "AWS::EC2::Subnet",
        Properties: {
          VpcId: vpcRef ? { Ref: vpcRef } : config.vpcId,
          CidrBlock: config.cidrBlock || "10.0.1.0/24",
          AvailabilityZone: config.availabilityZone || { "Fn::Select": [0, { "Fn::GetAZs": "" }] },
          MapPublicIpOnLaunch: config.isPublic || config.subnetType === "public",
          Tags: [{ Key: "Name", Value: label }],
        },
        DependsOn: vpcRef ? [vpcRef] : undefined,
      };

    case "internet-gateway":
    case "igw":
      return {
        Type: "AWS::EC2::InternetGateway",
        Properties: {
          Tags: [{ Key: "Name", Value: label }],
        },
      };

    case "nat-gateway":
    case "nat":
      const natSubnetRef = findParentRef(node, allNodes, "subnet");
      const eipLogicalId = `${logicalId}EIP`;
      return {
        Type: "AWS::EC2::NatGateway",
        Properties: {
          SubnetId: natSubnetRef ? { Ref: natSubnetRef } : config.subnetId,
          AllocationId: { "Fn::GetAtt": [eipLogicalId, "AllocationId"] },
          Tags: [{ Key: "Name", Value: label }],
        },
        DependsOn: natSubnetRef ? [natSubnetRef, eipLogicalId] : [eipLogicalId],
      };

    case "security-group":
    case "sg":
      const sgVpcRef = findParentRef(node, allNodes, "vpc");
      return {
        Type: "AWS::EC2::SecurityGroup",
        Properties: {
          GroupDescription: config.description || label,
          VpcId: sgVpcRef ? { Ref: sgVpcRef } : config.vpcId,
          SecurityGroupIngress: config.ingressRules || [
            { IpProtocol: "tcp", FromPort: 443, ToPort: 443, CidrIp: "0.0.0.0/0" },
            { IpProtocol: "tcp", FromPort: 80, ToPort: 80, CidrIp: "0.0.0.0/0" },
          ],
          Tags: [{ Key: "Name", Value: label }],
        },
        DependsOn: sgVpcRef ? [sgVpcRef] : undefined,
      };

    case "ec2":
    case "ec2-instance":
      const ec2SubnetRef = findParentRef(node, allNodes, "subnet");
      const ec2SgRef = findParentRef(node, allNodes, "security-group");
      return {
        Type: "AWS::EC2::Instance",
        Properties: {
          InstanceType: config.instanceType || "t3.micro",
          ImageId: config.ami || { Ref: "LatestAmiId" }, // Use SSM parameter for latest AMI
          SubnetId: ec2SubnetRef ? { Ref: ec2SubnetRef } : config.subnetId,
          SecurityGroupIds: ec2SgRef ? [{ Ref: ec2SgRef }] : config.securityGroupIds,
          Tags: [{ Key: "Name", Value: label }],
        },
        DependsOn: [ec2SubnetRef, ec2SgRef].filter(Boolean) as string[],
      };

    case "s3":
    case "s3-bucket":
      // AWS::S3::Bucket - https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-resource-s3-bucket.html
      return {
        Type: "AWS::S3::Bucket",
        Properties: {
          // BucketName is optional - CloudFormation generates unique name if not specified
          ...(config.bucketName && { BucketName: config.bucketName }),
          // Versioning - AWS recommends for data protection
          ...(config.versioning && { 
            VersioningConfiguration: { Status: "Enabled" } 
          }),
          // Public access block - AWS security best practice
          PublicAccessBlockConfiguration: {
            BlockPublicAcls: true,
            BlockPublicPolicy: true,
            IgnorePublicAcls: true,
            RestrictPublicBuckets: true,
          },
          // Server-side encryption - AWS security best practice
          BucketEncryption: {
            ServerSideEncryptionConfiguration: [{
              ServerSideEncryptionByDefault: {
                SSEAlgorithm: config.sseAlgorithm || "AES256",
              },
            }],
          },
          Tags: [{ Key: "Name", Value: label }],
        },
      };

    case "lambda":
    case "lambda-function":
      // AWS::Lambda::Function - https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-resource-lambda-function.html
      // Required: Code, Role
      return {
        Type: "AWS::Lambda::Function",
        Properties: {
          // FunctionName is optional - CloudFormation generates if not specified
          ...(config.functionName && { FunctionName: config.functionName }),
          // Runtime is required for zip deployments
          Runtime: config.runtime || "nodejs20.x",
          // Handler is required for zip deployments (format: file.method)
          Handler: config.handler || "index.handler",
          // Role is REQUIRED - must be IAM role ARN
          Role: config.roleArn || { "Fn::GetAtt": [`${logicalId}Role`, "Arn"] },
          // MemorySize: 128-10240 MB
          MemorySize: Math.min(Math.max(config.memorySize || 128, 128), 10240),
          // Timeout: 1-900 seconds
          Timeout: Math.min(Math.max(config.timeout || 30, 1), 900),
          // Code is REQUIRED - ZipFile for inline, S3Bucket/S3Key for S3
          Code: config.s3Bucket ? {
            S3Bucket: config.s3Bucket,
            S3Key: config.s3Key,
          } : {
            ZipFile: config.code || "exports.handler = async (event) => ({ statusCode: 200, body: JSON.stringify({ message: 'Hello from Lambda' }) });",
          },
          // Description - max 256 chars
          ...(config.description && { Description: config.description.substring(0, 256) }),
          Tags: [{ Key: "Name", Value: label }],
        },
        DependsOn: config.roleArn ? undefined : [`${logicalId}Role`],
      };

    case "dynamodb":
    case "dynamodb-table":
      return {
        Type: "AWS::DynamoDB::Table",
        Properties: {
          TableName: config.tableName || undefined,
          BillingMode: config.billingMode || "PAY_PER_REQUEST",
          AttributeDefinitions: [
            { AttributeName: config.partitionKey || "id", AttributeType: "S" },
          ],
          KeySchema: [
            { AttributeName: config.partitionKey || "id", KeyType: "HASH" },
          ],
          Tags: [{ Key: "Name", Value: label }],
        },
      };

    case "rds":
    case "rds-instance":
      // AWS::RDS::DBInstance - https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-resource-rds-dbinstance.html
      // Required: DBInstanceClass (Engine required unless restoring from snapshot)
      const rdsSubnetRef = findParentRef(node, allNodes, "subnet");
      const rdsSgRef = findParentRef(node, allNodes, "security-group");
      return {
        Type: "AWS::RDS::DBInstance",
        Properties: {
          // DBInstanceClass is REQUIRED - must start with "db."
          DBInstanceClass: config.instanceClass || "db.t3.micro",
          // Engine is required for new instances
          Engine: config.engine || "mysql",
          // EngineVersion - optional but recommended
          ...(config.engineVersion && { EngineVersion: config.engineVersion }),
          // MasterUsername - required for new instances (not from snapshot)
          MasterUsername: config.masterUsername || "admin",
          // MasterUserPassword - required for new instances
          // AWS recommends using Secrets Manager instead of plaintext
          MasterUserPassword: config.masterPassword || { Ref: "DBPassword" },
          // AllocatedStorage - must be string, 20-65536 GiB for most engines
          AllocatedStorage: String(config.allocatedStorage || 20),
          // StorageType - gp2, gp3, io1, or standard
          StorageType: config.storageType || "gp2",
          // StorageEncrypted - AWS security best practice
          StorageEncrypted: config.storageEncrypted !== false,
          // MultiAZ - recommended for production
          ...(config.multiAZ && { MultiAZ: true }),
          // VPCSecurityGroups
          ...(rdsSgRef && { VPCSecurityGroups: [{ Ref: rdsSgRef }] }),
          ...(config.securityGroupIds && { VPCSecurityGroups: config.securityGroupIds }),
          // DBSubnetGroupName - required for VPC
          ...(config.dbSubnetGroupName && { DBSubnetGroupName: config.dbSubnetGroupName }),
          // BackupRetentionPeriod - 0-35 days
          BackupRetentionPeriod: config.backupRetentionPeriod || 7,
          Tags: [{ Key: "Name", Value: label }],
        },
        DependsOn: [rdsSubnetRef, rdsSgRef].filter(Boolean) as string[],
      };

    case "sns":
    case "sns-topic":
      return {
        Type: "AWS::SNS::Topic",
        Properties: {
          TopicName: config.topicName || undefined,
          Tags: [{ Key: "Name", Value: label }],
        },
      };

    case "sqs":
    case "sqs-queue":
      return {
        Type: "AWS::SQS::Queue",
        Properties: {
          QueueName: config.queueName || undefined,
          VisibilityTimeout: config.visibilityTimeout || 30,
          Tags: [{ Key: "Name", Value: label }],
        },
      };

    case "alb":
    case "application-load-balancer":
      const albSubnetRefs = findAllParentRefs(node, allNodes, "subnet");
      const albSgRef = findParentRef(node, allNodes, "security-group");
      return {
        Type: "AWS::ElasticLoadBalancingV2::LoadBalancer",
        Properties: {
          Name: label,
          Type: "application",
          Subnets: albSubnetRefs.length > 0 
            ? albSubnetRefs.map(ref => ({ Ref: ref }))
            : config.subnetIds,
          SecurityGroups: albSgRef ? [{ Ref: albSgRef }] : config.securityGroupIds,
          Tags: [{ Key: "Name", Value: label }],
        },
      };

    case "api-gateway":
    case "apigateway":
      return {
        Type: "AWS::ApiGateway::RestApi",
        Properties: {
          Name: label,
          Description: config.description || `API Gateway for ${label}`,
        },
      };

    default:
      console.warn(`Unknown resource type: ${type}, skipping`);
      return null;
  }
}

/**
 * Find parent resource reference by type
 */
function findParentRef(node: Node, allNodes: Node[], parentType: string): string | null {
  // Look for a node of the parent type that was created before this one
  const parentNode = allNodes.find(n => {
    const type = n.data?.type || (n.data?.serviceId as string)?.split("-")[0];
    return type === parentType;
  });
  
  return parentNode ? sanitizeLogicalId(parentNode.id) : null;
}

/**
 * Find all parent refs of a type
 */
function findAllParentRefs(node: Node, allNodes: Node[], parentType: string): string[] {
  return allNodes
    .filter(n => {
      const type = n.data?.type || (n.data?.serviceId as string)?.split("-")[0];
      return type === parentType;
    })
    .map(n => sanitizeLogicalId(n.id));
}

/**
 * Add outputs for key resources
 */
function addOutputs(template: CloudFormationTemplate, nodes: Node[]): void {
  for (const node of nodes) {
    const type = node.data?.type || node.data?.serviceId?.split("-")[0];
    const logicalId = sanitizeLogicalId(node.id);

    switch (type) {
      case "vpc":
        template.Outputs![`${logicalId}Id`] = {
          Description: `VPC ID for ${logicalId}`,
          Value: { Ref: logicalId },
          Export: { Name: `${logicalId}-Id` },
        };
        break;
      case "s3":
        template.Outputs![`${logicalId}Name`] = {
          Description: `S3 Bucket Name for ${logicalId}`,
          Value: { Ref: logicalId },
        };
        break;
      case "lambda":
        template.Outputs![`${logicalId}Arn`] = {
          Description: `Lambda ARN for ${logicalId}`,
          Value: { "Fn::GetAtt": [logicalId, "Arn"] },
        };
        break;
    }
  }
}

/**
 * Sanitize node ID to valid CloudFormation logical ID
 */
function sanitizeLogicalId(id: string): string {
  // CloudFormation logical IDs must be alphanumeric
  return id.replace(/[^a-zA-Z0-9]/g, "");
}

// ============================================
// CLOUDFORMATION CLIENT
// ============================================

async function getCloudFormationClient(tenantId: string, region: string): Promise<CloudFormationClient | null> {
  const creds = await getAwsCredentials(tenantId);
  if (!creds.accessKeyId || !creds.secretAccessKey) {
    return null;
  }

  return new CloudFormationClient({
    region,
    credentials: {
      accessKeyId: creds.accessKeyId,
      secretAccessKey: creds.secretAccessKey,
    },
  });
}

// ============================================
// DEPLOYMENT FUNCTIONS
// ============================================

/**
 * Deploy architecture using CloudFormation
 */
export async function deployWithCloudFormation(
  architectureId: string,
  architectureName: string,
  nodes: Node[],
  edges: Edge[],
  tenantId: string,
  region: string = "us-east-1"
): Promise<DeploymentResult> {
  const stackName = `cloudmigrate-${sanitizeLogicalId(architectureName)}-${Date.now()}`;
  
  try {
    // Get CloudFormation client
    const client = await getCloudFormationClient(tenantId, region);
    if (!client) {
      return {
        success: false,
        stackName,
        status: "FAILED",
        error: "AWS credentials not configured",
      };
    }

    // Generate template
    const template = generateCloudFormationTemplate(nodes, edges, architectureName);
    
    // Validate template before deployment
    const validation = validateCloudFormationTemplate(template);
    if (!validation.valid) {
      const errorMessages = validation.errors.map(e => `${e.code}: ${e.message}`).join("; ");
      console.error(`[CloudFormation] Template validation failed:`, validation.errors);
      return {
        success: false,
        stackName,
        status: "VALIDATION_FAILED",
        error: `Template validation failed: ${errorMessages}`,
      };
    }
    
    // Log warnings but continue
    if (validation.warnings.length > 0) {
      console.warn(`[CloudFormation] Template warnings:`, validation.warnings);
    }
    
    const templateBody = JSON.stringify(template, null, 2);

    console.log(`[CloudFormation] Creating stack: ${stackName}`);
    console.log(`[CloudFormation] Template:\n${templateBody}`);

    // Create stack
    const createResponse = await client.send(new CreateStackCommand({
      StackName: stackName,
      TemplateBody: templateBody,
      Capabilities: ["CAPABILITY_IAM", "CAPABILITY_NAMED_IAM"], // For IAM resources
      Tags: [
        { Key: "ManagedBy", Value: "CloudMigrate" },
        { Key: "ArchitectureId", Value: architectureId },
      ],
      OnFailure: "ROLLBACK", // Rollback on failure
    }));

    const stackId = createResponse.StackId;
    console.log(`[CloudFormation] Stack creation initiated: ${stackId}`);

    // Wait for stack creation to complete
    console.log(`[CloudFormation] Waiting for stack creation to complete...`);
    await waitUntilStackCreateComplete(
      { client, maxWaitTime: 1800 }, // 30 minutes max
      { StackName: stackName }
    );

    // Get stack outputs
    const describeResponse = await client.send(new DescribeStacksCommand({
      StackName: stackName,
    }));

    const stack = describeResponse.Stacks?.[0];
    const outputs: Record<string, string> = {};
    
    for (const output of (stack?.Outputs || []) as any[]) {
      if (output.OutputKey && output.OutputValue) {
        outputs[output.OutputKey] = output.OutputValue;
      }
    }

    console.log(`[CloudFormation] Stack created successfully: ${stackName}`);

    return {
      success: true,
      stackId,
      stackName,
      status: stack?.StackStatus || "CREATE_COMPLETE",
      outputs,
    };

  } catch (error: any) {
    console.error(`[CloudFormation] Deployment failed:`, error);
    
    return {
      success: false,
      stackName,
      status: "FAILED",
      error: error.message || "CloudFormation deployment failed",
    };
  }
}

/**
 * Update existing stack
 */
export async function updateStack(
  stackName: string,
  nodes: Node[],
  edges: Edge[],
  architectureName: string,
  tenantId: string,
  region: string = "us-east-1"
): Promise<DeploymentResult> {
  try {
    const client = await getCloudFormationClient(tenantId, region);
    if (!client) {
      return {
        success: false,
        stackName,
        status: "FAILED",
        error: "AWS credentials not configured",
      };
    }

    const template = generateCloudFormationTemplate(nodes, edges, architectureName);
    const templateBody = JSON.stringify(template, null, 2);

    await client.send(new UpdateStackCommand({
      StackName: stackName,
      TemplateBody: templateBody,
      Capabilities: ["CAPABILITY_IAM", "CAPABILITY_NAMED_IAM"],
    }));

    await waitUntilStackUpdateComplete(
      { client, maxWaitTime: 1800 },
      { StackName: stackName }
    );

    return {
      success: true,
      stackName,
      status: "UPDATE_COMPLETE",
    };

  } catch (error: any) {
    return {
      success: false,
      stackName,
      status: "FAILED",
      error: error.message,
    };
  }
}

/**
 * Delete stack
 */
export async function deleteStack(
  stackName: string,
  tenantId: string,
  region: string = "us-east-1"
): Promise<DeploymentResult> {
  try {
    const client = await getCloudFormationClient(tenantId, region);
    if (!client) {
      return {
        success: false,
        stackName,
        status: "FAILED",
        error: "AWS credentials not configured",
      };
    }

    await client.send(new DeleteStackCommand({
      StackName: stackName,
    }));

    await waitUntilStackDeleteComplete(
      { client, maxWaitTime: 1800 },
      { StackName: stackName }
    );

    return {
      success: true,
      stackName,
      status: "DELETE_COMPLETE",
    };

  } catch (error: any) {
    return {
      success: false,
      stackName,
      status: "FAILED",
      error: error.message,
    };
  }
}

/**
 * List stack resources (for creating CloudResource records)
 */
export async function listStackResources(
  stackName: string,
  tenantId: string,
  region: string = "us-east-1"
): Promise<Array<{
  logicalId: string;
  physicalId: string;
  type: string;
  status: string;
}>> {
  try {
    const { ListStackResourcesCommand } = await import("@aws-sdk/client-cloudformation");
    const client = await getCloudFormationClient(tenantId, region);
    if (!client) return [];

    const response = await client.send(new ListStackResourcesCommand({
      StackName: stackName,
    }));

    return (response.StackResourceSummaries || []).map((r: any) => ({
      logicalId: r.LogicalResourceId || "",
      physicalId: r.PhysicalResourceId || "",
      type: r.ResourceType || "",
      status: r.ResourceStatus || "",
    }));
  } catch (error) {
    console.error("Failed to list stack resources:", error);
    return [];
  }
}

/**
 * Check if stack exists
 */
export async function stackExists(
  stackName: string,
  tenantId: string,
  region: string = "us-east-1"
): Promise<boolean> {
  try {
    const client = await getCloudFormationClient(tenantId, region);
    if (!client) return false;

    const response = await client.send(new DescribeStacksCommand({
      StackName: stackName,
    }));

    const stack = response.Stacks?.[0];
    // Stack exists if it's not in a deleted state
    return stack?.StackStatus !== "DELETE_COMPLETE" && stack?.StackStatus !== undefined;
  } catch (error: any) {
    // Stack doesn't exist
    if (error.name === "ValidationError" && error.message?.includes("does not exist")) {
      return false;
    }
    return false;
  }
}

/**
 * Get stack status and events
 */
export async function getStackStatus(
  stackName: string,
  tenantId: string,
  region: string = "us-east-1"
): Promise<{
  status: string;
  events: Array<{ timestamp: Date; status: string; reason?: string; resourceId?: string }>;
}> {
  const client = await getCloudFormationClient(tenantId, region);
  if (!client) {
    return { status: "UNKNOWN", events: [] };
  }

  try {
    const [stackResponse, eventsResponse] = await Promise.all([
      client.send(new DescribeStacksCommand({ StackName: stackName })),
      client.send(new DescribeStackEventsCommand({ StackName: stackName })),
    ]);

    const status = stackResponse.Stacks?.[0]?.StackStatus || "UNKNOWN";
    const events = (eventsResponse.StackEvents || []).slice(0, 20).map((e: any) => ({
      timestamp: e.Timestamp || new Date(),
      status: e.ResourceStatus || "",
      reason: e.ResourceStatusReason,
      resourceId: e.LogicalResourceId,
    }));

    return { status, events };

  } catch (error) {
    return { status: "UNKNOWN", events: [] };
  }
}

// ============================================
// COST ESTIMATOR
// ============================================

// Rough monthly cost estimates per resource type (USD)
const COST_ESTIMATES: Record<string, { min: number; max: number }> = {
  "vpc": { min: 0, max: 0 }, // VPCs are free
  "subnet": { min: 0, max: 0 },
  "internet-gateway": { min: 0, max: 0 },
  "nat-gateway": { min: 32, max: 45 }, // ~$0.045/hr + data
  "security-group": { min: 0, max: 0 },
  "ec2": { min: 8, max: 100 }, // t3.micro to t3.large
  "rds": { min: 15, max: 200 },
  "lambda": { min: 0, max: 20 }, // Pay per invocation
  "s3": { min: 1, max: 50 },
  "dynamodb": { min: 0, max: 25 }, // On-demand
  "sns": { min: 0, max: 5 },
  "sqs": { min: 0, max: 5 },
  "alb": { min: 20, max: 50 },
  "api-gateway": { min: 3, max: 30 },
};

/**
 * Estimate monthly cost for architecture
 */
export function estimateArchitectureCost(nodes: Node[]): { 
  monthly: number; 
  breakdown: { resource: string; cost: number }[] 
} {
  const breakdown: { resource: string; cost: number }[] = [];
  let total = 0;

  for (const node of nodes) {
    const type = node.data?.type || (node.data?.serviceId as string)?.split("-")[0];
    const estimate = COST_ESTIMATES[type];
    
    if (estimate) {
      const avgCost = (estimate.min + estimate.max) / 2;
      breakdown.push({
        resource: node.data?.label || node.data?.name || type,
        cost: avgCost,
      });
      total += avgCost;
    }
  }

  return { monthly: total, breakdown };
}

// ============================================
// VALIDATION
// ============================================

/**
 * Validate architecture before deployment
 */
export function validateArchitecture(nodes: Node[], edges: Edge[]): { 
  valid: boolean; 
  errors: string[] 
} {
  const errors: string[] = [];

  if (nodes.length === 0) {
    errors.push("Architecture has no resources");
    return { valid: false, errors };
  }

  // Check for VPC requirement
  const hasVpc = nodes.some(n => {
    const type = n.data?.type || (n.data?.serviceId as string)?.split("-")[0];
    return type === "vpc";
  });

  const hasEc2OrRds = nodes.some(n => {
    const type = n.data?.type || (n.data?.serviceId as string)?.split("-")[0];
    return ["ec2", "rds", "ecs"].includes(type);
  });

  if (hasEc2OrRds && !hasVpc) {
    errors.push("EC2/RDS instances require a VPC");
  }

  // Check for subnet requirement
  const hasSubnet = nodes.some(n => {
    const type = n.data?.type || (n.data?.serviceId as string)?.split("-")[0];
    return type === "subnet";
  });

  if (hasEc2OrRds && !hasSubnet) {
    errors.push("EC2/RDS instances require a Subnet");
  }

  return { valid: errors.length === 0, errors };
}
