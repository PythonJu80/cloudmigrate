import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { getSecret } from "@/lib/secrets";
import { getNodeDefinition, getNodeListForPrompt } from "@/lib/cloudflow/nodes/registry";

// Build system prompt dynamically with all available nodes
function buildGenerationPrompt(): string {
  const nodeList = getNodeListForPrompt();
  
  return `You are a workflow generator. Based on the conversation, create a CloudFlow workflow.

Output ONLY valid JSON, no explanation. Format:
{
  "name": "Workflow Name",
  "description": "Brief description",
  "nodes": [
    {"id": "node-1", "definitionId": "trigger.webhook", "position": {"x": 100, "y": 100}, "data": {"config": {}}}
  ],
  "edges": [
    {"id": "edge-1", "source": "node-1", "target": "node-2"}
  ]
}

IMPORTANT: Use ONLY these exact node definitionIds from the registry:

${nodeList}

Layout rules:
- Position nodes 250px apart horizontally starting at x:100
- For branching workflows, position branches vertically: y=100 (main), y=250 (branch 1), y=400 (branch 2), y=550 (branch 3)
- Each node needs a unique id like "node-1", "node-2", etc.
- Connect nodes with edges using source and target node ids

Output ONLY the JSON object, nothing else.`;
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.tenantId || !session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { chatHistory } = await request.json();

    if (!chatHistory || chatHistory.length === 0) {
      return NextResponse.json({ error: "No conversation to generate from" }, { status: 400 });
    }

    // Get API key
    const apiKey = await getSecret(session.user.tenantId, "OPENAI_API_KEY");
    if (!apiKey) {
      return NextResponse.json({ error: "OPENAI_API_KEY not configured" }, { status: 400 });
    }

    // Call OpenAI to generate workflow
    const messages = [
      { role: "system", content: buildGenerationPrompt() },
      ...chatHistory.map((m: any) => ({ role: m.role, content: m.content })),
      { role: "user", content: "Generate the workflow JSON now based on our conversation." }
    ];

    // Use GPT-4.1 for generation (supports max_tokens)
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: "gpt-4.1",
        messages,
        temperature: 0.3,
        max_completion_tokens: 4096,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || "OpenAI API error");
    }

    const data = await response.json();
    const content = data.choices[0]?.message?.content || "";

    // Parse the JSON - try to extract from code block if present
    let workflowData;
    try {
      // Try direct parse first
      workflowData = JSON.parse(content);
    } catch {
      // Try extracting from code block
      const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        workflowData = JSON.parse(jsonMatch[1]);
      } else {
        throw new Error("Failed to parse workflow JSON");
      }
    }

    // Map nodes to proper format for React Flow with registry metadata
    const nodes = (workflowData.nodes || []).map((node: any, index: number) => {
      const definition = getNodeDefinition(node.definitionId);
      const nodeId = node.id || `node-${index + 1}`;
      
      return {
        id: nodeId,
        type: "cloudflow",
        position: node.position || { x: 100 + index * 250, y: 100 },
        data: {
          id: nodeId,
          definitionId: node.definitionId,
          label: definition?.label || node.definitionId,
          icon: definition?.icon || "Server",
          color: definition?.color || "#6b7280",
          config: node.data?.config || {},
        },
      };
    });

    const edges = (workflowData.edges || []).map((edge: any) => ({
      id: edge.id,
      source: edge.source,
      target: edge.target,
      sourceHandle: "output",
      targetHandle: "input",
      type: "smoothstep",
      animated: true,
    }));

    // Save to database
    const flow = await prisma.cloudFlow.create({
      data: {
        tenantId: session.user.tenantId,
        userId: session.user.id,
        name: workflowData.name || "AI Generated Workflow",
        description: workflowData.description || "Generated by Workflow Agent",
        nodes: JSON.stringify(nodes),
        edges: JSON.stringify(edges),
        status: "draft",
      },
    });

    return NextResponse.json({
      success: true,
      flowId: flow.id,
      name: flow.name,
    });
  } catch (error: any) {
    console.error("Workflow generation error:", error);
    return NextResponse.json(
      { error: error.message || "Failed to generate workflow" },
      { status: 500 }
    );
  }
}
