import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { getSecret } from "@/lib/secrets";
import { GENERATION_PROMPT } from "@/lib/architecture/agents/architecture-agent";

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.tenantId || !session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { chatHistory } = await request.json();

    if (!chatHistory || chatHistory.length === 0) {
      return NextResponse.json({ error: "No conversation to generate from" }, { status: 400 });
    }

    // Get API key
    const apiKey = await getSecret(session.user.tenantId, "OPENAI_API_KEY");
    if (!apiKey) {
      return NextResponse.json({ error: "OPENAI_API_KEY not configured" }, { status: 400 });
    }

    // Call OpenAI to generate architecture
    const messages = [
      { role: "system", content: GENERATION_PROMPT },
      ...chatHistory.map((m: any) => ({ role: m.role, content: m.content })),
      { role: "user", content: "Generate the architecture JSON now based on our conversation." }
    ];

    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: "gpt-4.1",
        messages,
        temperature: 0.3,
        max_tokens: 8192,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || "OpenAI API error");
    }

    const data = await response.json();
    const content = data.choices[0]?.message?.content || "";

    // Parse the JSON - try to extract from code block if present
    let archData;
    try {
      // Try direct parse first
      archData = JSON.parse(content);
    } catch {
      // Try extracting from code block
      const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        // Strip comments
        let jsonStr = jsonMatch[1]
          .replace(/\/\/.*$/gm, '')
          .replace(/\/\*[\s\S]*?\*\//g, '')
          .replace(/,(\s*[}\]])/g, '$1');
        archData = JSON.parse(jsonStr);
      } else {
        throw new Error("Failed to parse architecture JSON");
      }
    }

    // Validate and map nodes
    const nodes = (archData.nodes || []).map((node: any, index: number) => ({
      id: node.id || `node-${index + 1}`,
      type: node.type || "awsResource",
      position: node.position || { x: 100 + index * 200, y: 100 },
      data: {
        serviceId: node.data?.serviceId || node.serviceId,
        label: node.data?.label || node.label,
        sublabel: node.data?.sublabel || node.sublabel || "",
        type: node.data?.type || node.type,
        icon: node.data?.icon || `/aws-icons/${node.data?.serviceId || 'ec2'}.svg`,
        color: node.data?.color || "#ED7100",
      },
      zIndex: node.zIndex || 10,
    }));

    const edges = (archData.edges || []).map((edge: any) => ({
      id: edge.id,
      source: edge.source,
      target: edge.target,
      type: edge.type || "smoothstep",
      animated: edge.animated !== false,
      style: edge.style || { stroke: "#22d3ee", strokeWidth: 2 },
    }));

    // Calculate estimated cost
    const estimatedCost = archData.estimatedCost 
      ? (archData.estimatedCost.min + archData.estimatedCost.max) / 2 
      : nodes.length * 50; // Rough estimate

    // Save to database
    const architecture = await prisma.architecture.create({
      data: {
        tenantId: session.user.tenantId,
        userId: session.user.id,
        name: archData.name || "AI Generated Architecture",
        description: archData.description || "Generated by Architecture Agent",
        nodes: JSON.stringify(nodes),
        edges: JSON.stringify(edges),
        estimatedCost,
        status: "draft",
      },
    });

    return NextResponse.json({
      success: true,
      archId: architecture.id,
      name: architecture.name,
    });
  } catch (error: any) {
    console.error("Architecture generation error:", error);
    return NextResponse.json(
      { error: error.message || "Failed to generate architecture" },
      { status: 500 }
    );
  }
}
